{"version":3,"sources":["components/Timer/index.js","components/Timer/hooks/useInterval.js","components/Button/index.js","components/Label/index.js","components/app/index.js","serviceWorker.js","index.js"],"names":["Timer","useContext","TimerContext","session","timer","useState","minutes","remainingTime","toString","seconds","clock","setClock","updateTimerValue","useEffect","callback","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","isRunning","asSeconds","setRemainingTime","subtract","sessionType","SessionContants","WORKING_SESSION","Moment","duration","setSessionType","RESTING_SESSION","Button","onClick","children","type","Label","LONG_RESTING_SESSION","renderSessionName","React","createContext","Index","setIsRunning","restartSession","className","Provider","value","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.ea394ecf.chunk.js","sourcesContent":["import React, { useContext, useEffect, useState } from 'react';\nimport Moment from 'moment';\nimport useInterval from './hooks/useInterval';\nimport { TimerContext, SessionContants } from '../app';\n\nconst Timer = () => {\n\tconst {\n\t\tsession,\n\t\ttimer,\n\t} = useContext(TimerContext);\n\n\tconst [clock, setClock] = useState({\n\t\tminutes: timer.remainingTime.minutes().toString(),\n\t\tseconds: timer.remainingTime.seconds().toString(),\n\t});\n\n\tfunction updateTimerValue(minutes, seconds) {\n\t\tsetClock({\n\t\t\tminutes, seconds,\n\t\t});\n\t}\n\n\tfunction tickClock() {\n\t\tif (timer.remainingTime.asSeconds() > 0) {\n\t\t\ttimer.setRemainingTime(timer.remainingTime.subtract(1, 'seconds'));\n\t\t} else if (session.sessionType === SessionContants.WORKING_SESSION) {\n\t\t\ttimer.setRemainingTime(Moment.duration(5, 'minutes'));\n\t\t\tsession.setSessionType(SessionContants.RESTING_SESSION);\n\t\t} else {\n\t\t\ttimer.setRemainingTime(Moment.duration(25, 'minutes'));\n\t\t\tsession.setSessionType(SessionContants.WORKING_SESSION);\n\t\t}\n\t\tupdateTimerValue(\n\t\t\ttimer.remainingTime.minutes().toString(),\n\t\t\ttimer.remainingTime.seconds().toString(),\n\t\t);\n\t}\n\n\t// Hooks\n\tuseEffect(() => {\n\t\tupdateTimerValue(\n\t\t\ttimer.remainingTime.minutes().toString(),\n\t\t\ttimer.remainingTime.seconds().toString(),\n\t\t);\n\t}, [timer]);\n\n\tuseInterval(() => {\n\t\tif (timer.isRunning) {\n\t\t\ttickClock();\n\t\t}\n\t}, 1000);\n\n\treturn (\n\t\t<>\n\t\t\t<h2>{`${clock.minutes}:${clock.seconds}`}</h2>\n\t\t</>\n\t);\n};\nexport default Timer;\n","import { useEffect, useRef } from 'react';\n\nexport default (callback, delay) => {\n\tconst savedCallback = useRef();\n\t// Remember the latest callback.\n\tuseEffect(() => {\n\t\tsavedCallback.current = callback;\n\t}, [callback]);\n\t// Set up the interval.\n\tuseEffect(() => {\n\t\tfunction tick() {\n\t\t\tsavedCallback.current();\n\t\t}\n\t\tconst id = setInterval(tick, delay);\n\t\treturn () => clearInterval(id);\n\t}, [delay]);\n};\n","import React from 'react';\n\nconst Button = ({ onClick, children }) => (\n\t<button\n\t\tonClick={onClick}\n\t\ttype=\"button\"\n\t>\n\t\t{children}\n\t</button>\n);\n\nexport default Button;\n","import React, { useContext } from 'react';\nimport {\n\tTimerContext,\n\tSessionContants,\n} from '../app';\n\nconst Label = () => {\n\tconst {\n\t\tsession,\n\t} = useContext(TimerContext);\n\n\tfunction renderSessionName() {\n\t\tswitch (session.sessionType) {\n\t\tcase SessionContants.WORKING_SESSION:\n\t\t\treturn 'Working Session';\n\t\tcase SessionContants.RESTING_SESSION:\n\t\t\treturn 'Resting Session';\n\t\tcase SessionContants.LONG_RESTING_SESSION:\n\t\t\treturn 'Long Resting Session';\n\t\tdefault:\n\t\t\treturn '';\n\t\t}\n\t}\n\n\treturn (\n\t\t<h3>{renderSessionName()}</h3>\n\t);\n};\n\nexport default Label;\n","import React, { useState } from 'react';\nimport Moment from 'moment';\n\nimport './App.css';\n\nimport Timer from '../Timer';\nimport Button from '../Button';\nimport Label from '../Label';\n\nexport const TimerContext = React.createContext(null);\nexport const SessionContants = {\n\tWORKING_SESSION: 'WORKING_SESSION',\n\tRESTING_SESSION: 'RESTING_SESSION',\n\tLONG_RESTING_SESSION: 'LONG_RESTING_SESSION',\n};\n\nconst Index = () => {\n\tconst [sessionType, setSessionType] = useState(SessionContants.WORKING_SESSION);\n\tconst [isRunning, setIsRunning] = useState(false);\n\tconst [remainingTime, setRemainingTime] = useState(Moment.duration(25, 'minutes'));\n\n\tconst restartSession = () => {\n\t\tconst duration = sessionType === SessionContants.WORKING_SESSION ? 25 : 5;\n\t\tsetRemainingTime(Moment.duration(duration, 'minutes'));\n\t};\n\n\tconst stopSession = () => {\n\t\tsetIsRunning(false);\n\t\trestartSession();\n\t};\n\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<header className=\"App-header\">\n\t\t\t\t<h1>Pomodoro Timer</h1>\n\t\t\t\t<TimerContext.Provider\n\t\t\t\t\tvalue={{\n\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\tsessionType,\n\t\t\t\t\t\t\tsetSessionType,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttimer: {\n\t\t\t\t\t\t\tremainingTime,\n\t\t\t\t\t\t\tsetRemainingTime,\n\t\t\t\t\t\t\tisRunning,\n\t\t\t\t\t\t\tsetIsRunning,\n\t\t\t\t\t\t},\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<Timer />\n\t\t\t\t\t<Label />\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<Button onClick={() => setIsRunning(true)}>Start</Button>\n\t\t\t\t\t\t<Button onClick={() => setIsRunning(false)}>Pause</Button>\n\t\t\t\t\t\t<Button onClick={restartSession}>Restart</Button>\n\t\t\t\t\t\t<Button onClick={stopSession}>Stop</Button>\n\t\t\t\t\t</div>\n\t\t\t\t</TimerContext.Provider>\n\t\t\t</header>\n\t\t</div>\n\t);\n};\n\nexport default Index;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n\twindow.location.hostname === 'localhost'\n    // [::1] is the IPv6 localhost address.\n    || window.location.hostname === '[::1]'\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    || window.location.hostname.match(\n    \t/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\nexport function register(config) {\n\tif (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n\t\t// The URL constructor is available in all browsers that support SW.\n\t\tconst publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n\t\tif (publicUrl.origin !== window.location.origin) {\n\t\t\t// Our service worker won't work if PUBLIC_URL is on a different origin\n\t\t\t// from what our page is served on. This might happen if a CDN is used to\n\t\t\t// serve assets; see https://github.com/facebook/create-react-app/issues/2374\n\t\t\treturn;\n\t\t}\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tconst swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n\t\t\tif (isLocalhost) {\n\t\t\t\t// This is running on localhost. Let's check if a service worker still exists or not.\n\t\t\t\tcheckValidServiceWorker(swUrl, config);\n\n\t\t\t\t// Add some additional logging to localhost, pointing developers to the\n\t\t\t\t// service worker/PWA documentation.\n\t\t\t\tnavigator.serviceWorker.ready.then(() => {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t'This web app is being served cache-first by a service '\n              + 'worker. To learn more, visit https://bit.ly/CRA-PWA',\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Is not localhost. Just register service worker\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction registerValidSW(swUrl, config) {\n\tnavigator.serviceWorker\n\t\t.register(swUrl)\n\t\t.then((registration) => {\n\t\t\tregistration.onupdatefound = () => {\n\t\t\t\tconst installingWorker = registration.installing;\n\t\t\t\tif (installingWorker == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tinstallingWorker.onstatechange = () => {\n\t\t\t\t\tif (installingWorker.state === 'installed') {\n\t\t\t\t\t\tif (navigator.serviceWorker.controller) {\n\t\t\t\t\t\t\t// At this point, the updated precached content has been fetched,\n\t\t\t\t\t\t\t// but the previous service worker will still serve the older\n\t\t\t\t\t\t\t// content until all client tabs are closed.\n\t\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t\t'New content is available and will be used when all '\n                  + 'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onUpdate) {\n\t\t\t\t\t\t\t\tconfig.onUpdate(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// At this point, everything has been precached.\n\t\t\t\t\t\t\t// It's the perfect time to display a\n\t\t\t\t\t\t\t// \"Content is cached for offline use.\" message.\n\t\t\t\t\t\t\tconsole.log('Content is cached for offline use.');\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onSuccess) {\n\t\t\t\t\t\t\t\tconfig.onSuccess(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error('Error during service worker registration:', error);\n\t\t});\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n\t// Check if the service worker can be found. If it can't reload the page.\n\tfetch(swUrl, {\n\t\theaders: { 'Service-Worker': 'script' },\n\t})\n\t\t.then((response) => {\n\t\t\t// Ensure service worker exists, and that we really are getting a JS file.\n\t\t\tconst contentType = response.headers.get('content-type');\n\t\t\tif (\n\t\t\t\tresponse.status === 404\n        || (contentType != null && contentType.indexOf('javascript') === -1)\n\t\t\t) {\n\t\t\t\t// No service worker found. Probably a different app. Reload the page.\n\t\t\t\tnavigator.serviceWorker.ready.then((registration) => {\n\t\t\t\t\tregistration.unregister().then(() => {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Service worker found. Proceed as normal.\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t})\n\t\t.catch(() => {\n\t\t\tconsole.log(\n\t\t\t\t'No internet connection found. Index is running in offline mode.',\n\t\t\t);\n\t\t});\n}\n\nexport function unregister() {\n\tif ('serviceWorker' in navigator) {\n\t\tnavigator.serviceWorker.ready\n\t\t\t.then((registration) => {\n\t\t\t\tregistration.unregister();\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tconsole.error(error.message);\n\t\t\t});\n\t}\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Index from './components/app';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<Index />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.register();\nserviceWorker.unregister();\n"],"sourceRoot":""}